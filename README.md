<공유메모리의 내용>
turn_complete -> 턴이 완료되었는지 아닌지
bomb_owner -> 폭탄을 들고 있는 클라이언트의 ID (0, 1, 2, 3)
timer -> 남아있는 타이머 카운트 시간

<메인 프로세스 (부모)>

서버 소켓에 클라이언트 소켓(유니티측) 접속되면 자식 프로세스 생성.

ready_count가 필요 클라이언트 수가 될 때까지 FIFO를 읽음.
FIFO에서 읽은 값이 있을 때마다 ready_count를 + 1 하는 방식으로 준비된 클라이언트 수를 확인

모든 클라이언트의 준비가 끝났으면 게임 시작

공유메모리의 timer(랜덤값)와 bomb_owner(0부터 시작)를 설정


공유메모리의 timer값이 0보다 클 동안 이 내용을 반복 {

	자식 프로세스들에게 시그널 보냄. (다음 턴이 시작되었다는 신호)

	턴 완료 시그널 대기

	턴 완료되었으면 공유메모리의 bomb_owner를 다음 순서로 설정하고 이것을 반복
}

타이머가 0보다 작거나 같아지면 반복문을 빠져나와서
자식 프로세스들에게 게임 종료 시그널을 보냄


<클라이언트 프로세스 (자식)>

시그널 받을 준비, 공유메모리 받기 등의 처리가 다 끝났으면 FIFO로 준비완료 메시지를 씀.

그리고 메인프로세스에서 시그널을 줄 때까지 대기

-> 다음 턴 시작 시그널을 받으면
	공유메모리의 bomb_owner와 timer를 유니티로 전달.
	
	본인의 clientID와 bomb_owner가 일치하면 (즉 자신의 턴일 경우)
	유니티로부터 받은 timer값으로 공유메모리를 갱신하고
	부모프로세스로 턴 완료 시그널을 보냄	

->게임 종료 시그널을 받으면
	유니티에게 bomb_owner와 timer값을 모두 -1로 전달 (게임이 종료되었다는 뜻)


<유니티 클라이언트>
클라이언트 프로세스로부터 데이터(timer와 bomb_owner)를 받음
폭탄의 위치를 bomb_owner에 해당하는 자리로 옮김

bomb_owner가 자신일 경우 -> 패스 버튼을 활성화, timer 감소
	패스버튼이 눌리거나, timer의 값이 0보다 작거나 같아지면
	그 순간의 timer 값을 클라이언트 프로세스로 전달


bomb_owner가 자신이 아닐 경우 -> 패스 버튼 비활성화.

timer가 0보다 작거나 같을 경우 -> 게임종료 (폭탄이 터지는 연출)
